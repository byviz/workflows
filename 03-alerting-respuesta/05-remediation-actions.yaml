# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# WORKFLOW: Acciones de RemediaciÃ³n AutomÃ¡tica
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
name: remediation-actions
description: |
  Ejecuta acciones de remediaciÃ³n bÃ¡sicas automÃ¡ticamente.
  
  Ejemplos:
  - Reiniciar servicio degradado
  - Limpiar cache
  - Escalar recursos
  - Ejecutar health check
enabled: true
tags: ["remediation", "auto-heal", "recovery"]

triggers:
  - type: alert

steps:
  # 1. Diagnosticar el problema
  - name: diagnosticar
    type: elasticsearch.search
    with:
      index: "logs-*,metrics-*"
      query:
        bool:
          should:
            - match:
                message: "OutOfMemory"
            - match:
                message: "Connection pool exhausted"
            - match:
                message: "Disk full"
          minimum_should_match: 1
          filter:
            - range:
                "@timestamp":
                  gte: "now-10m"
      size: 10
      aggregations:
        por_tipo_error:
          terms:
            field: "error.type"
            size: 10
  
  # 2. Decidir acciÃ³n segÃºn tipo de error
  - name: decidir_remediacion
    type: foreach
    with:
      items: "{{steps.diagnosticar.output.aggregations.por_tipo_error.buckets}}"
      do:
        - type: console
          with:
            message: |
              ğŸ”§ RemediaciÃ³n sugerida para: {{item.key}}
              
              {% if item.key contains "Memory" %}
              â¡ï¸  ACCIÃ“N: Restart service con mÃ¡s memoria
              Comando: kubectl scale deployment app --replicas=0 && kubectl scale deployment app --replicas=3
              {% elsif item.key contains "Connection" %}
              â¡ï¸  ACCIÃ“N: Limpiar connection pool
              Comando: curl -X POST http://app/admin/pool/reset
              {% elsif item.key contains "Disk" %}
              â¡ï¸  ACCIÃ“N: Limpiar logs antiguos
              Comando: find /var/log -mtime +7 -delete
              {% else %}
              â¡ï¸  ACCIÃ“N: Health check general
              Comando: curl http://app/health
              {% endif %}
  
  # 3. Ejecutar acciÃ³n (simulado - en producciÃ³n usar http.request o webhook)
  - name: ejecutar_accion
    type: console
    with:
      message: |
        â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        ğŸ› ï¸  REMEDIACIÃ“N AUTOMÃTICA
        â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        Timestamp: {{now | date: "%Y-%m-%d %H:%M:%S"}}
        
        Problemas detectados:
        {% for bucket in steps.diagnosticar.output.aggregations.por_tipo_error.buckets %}
        - {{bucket.key}}: {{bucket.doc_count}} ocurrencias
        {% endfor %}
        
        âš ï¸  NOTA: En este ejemplo, las acciones son simuladas.
        
        En producciÃ³n, este workflow puede:
        - Llamar APIs de Kubernetes
        - Ejecutar scripts vÃ­a webhooks
        - Trigger runbooks en automation platform
        - Ejecutar comandos via SSH (con precauciÃ³n)
        
        â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  # 4. Esperar y verificar
  - name: esperar_recuperacion
    type: wait
    with:
      duration: "30s"
  
  # 5. Verificar si se resolviÃ³
  - name: verificar_resolucion
    type: elasticsearch.search
    with:
      index: "logs-*"
      query:
        bool:
          must:
            - match:
                log.level: "ERROR"
          filter:
            - range:
                "@timestamp":
                  gte: "now-1m"
      size: 0
  
  # 6. Reporte final
  - name: reporte_remediacion
    type: console
    with:
      message: |
        ğŸ“‹ REPORTE DE REMEDIACIÃ“N
        
        Estado actual: {% if steps.verificar_resolucion.output.hits.total.value < 10 %}âœ… RESUELTO{% else %}âŒ PERSISTE{% endif %}
        
        Errores antes: {{steps.diagnosticar.output.hits.total.value}}
        Errores despuÃ©s: {{steps.verificar_resolucion.output.hits.total.value}}
        
        {% if steps.verificar_resolucion.output.hits.total.value < 10 %}
        âœ… La remediaciÃ³n automÃ¡tica fue exitosa
        {% else %}
        âš ï¸  El problema persiste - escalando a humanos
        {% endif %}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# âš ï¸  IMPORTANTE - REMEDIACIÃ“N AUTOMÃTICA
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#
# La remediaciÃ³n automÃ¡tica puede ser poderosa pero tambiÃ©n riesgosa.
#
# RECOMENDACIONES:
# âœ… Empezar con acciones de bajo riesgo (health checks, limpiezas)
# âœ… Testear exhaustivamente en staging
# âœ… Implementar circuit breakers (no ejecutar mÃ¡s de X veces por hora)
# âœ… Loguear todas las acciones para auditorÃ­a
# âœ… Tener rollback plan
# âœ… Alertar a humanos antes de acciones crÃ­ticas
#
# ACCIONES SEGURAS:
# - Health checks
# - Limpiar cache
# - Restart de servicios no crÃ­ticos
# - Escalar horizontalmente
#
# ACCIONES RIESGOSAS (requieren aprobaciÃ³n):
# - Restart de bases de datos
# - Cambios en producciÃ³n
# - EliminaciÃ³n de datos
# - Cambios de configuraciÃ³n crÃ­tica
#
# Siempre prioriza la seguridad sobre la automatizaciÃ³n.
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

